<jqassistant-rules xmlns="http://schema.jqassistant.org/rule/v2.2"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://schema.jqassistant.org/rule/v2.2 https://jqassistant.github.io/jqassistant/current/schema/jqassistant-rule-v2.2.xsd">

    <group id="preparation:Default">
        <includeConcept refId="preparation:BiojavaTypes"/>
        <includeConcept refId="pmd:LinkClassLevelViolations"/>
        <includeConcept refId="pmd:LinkMethodLevelViolations"/>
        <includeConcept refId="pmd:LinkMethodLevelViolationsSingleCandidate"/>
        <includeConcept refId="pmd:CopyCyclomaticComplexity"/>
        <includeConcept refId="pmd:CopyNcssLineCount"/>
        <includeConcept refId="sig:CreateComponentNodes"/>
        <includeConcept refId="sig:MapTypesToComponents"/>

        <includeConstraint refId="pmd:ClassLevelViolationNotLinked"/>
        <includeConstraint refId="pmd:MethodLevelViolationNotLinked"/>
    </group>

    <concept id="preparation:BiojavaTypes">
        <description>Markiert alle Klassen und Packages von Biojava mit :Biojava</description>
        <cypher><![CDATA[
            MATCH   (a:Main:Artifact)
            WHERE   a.group STARTS WITH "org.biojava"
            SET     a:Biojava
            WITH    a
            OPTIONAL MATCH (a)-[:CONTAINS]->(any)
            SET     any:Biojava
            RETURN  count(DISTINCT a) AS Artifacts, count(DISTINCT any) AS Elements
        ]]></cypher>
    </concept>

    <concept id="pmd:LinkClassLevelViolations">
        <requiresConcept refId="preparation:BiojavaTypes"/>
        <description>Link PMD Violations on class level to the class nodes</description>
        <cypher><![CDATA[
            MATCH  (v:Pmd:Violation),
                   (t:Biojava:Type:Java{fqn: v.package + "." + v.className})
            WHERE  NOT exists(v.method)
            MERGE  (t)-[:HAS_VIOLATION]->(v)
            RETURN count(DISTINCT t) AS LinkedTypes
        ]]></cypher>
        <verify>
            <aggregation/>
        </verify>
    </concept>

    <concept id="pmd:LinkMethodLevelViolations">
        <requiresConcept refId="preparation:BiojavaTypes"/>
        <description>Link PMD Violations on method level to the method nodes</description>
        <cypher><![CDATA[
            MATCH  (v:Pmd:Violation),
                   (t:Biojava:Type{fqn: v.package + "." + v.className}),
                   (t)-[:DECLARES]->(m:Method)
            WITH   v, t, m, size(split(t.name, "$")) AS l
            WITH   v, t, m, split(t.name, "$")[l - 1] AS TypeName
            WITH   v, t, m, replace(m.name, "<init>", TypeName) AS MethodName
            WHERE  v.method = MethodName
            OPTIONAL MATCH (m)-[:HAS]->(p:Parameter)-[:OF_TYPE]->(pType:Type)
            WITH   v, t, m, p, pType, size(split(pType.name, "$")) AS l
            WITH   v, t, m, p, split(pType.name,"$")[l - 1] AS ParamType
            ORDER BY t, m, p.index ASC, ParamType
            WITH   v, t, m, collect(ParamType) AS params
            WITH   v, t, m, REDUCE(mergedParams = "",param IN params | mergedParams + CASE WHEN mergedParams = '' THEN '' ELSE ', ' END + param) AS mergedParams
            WITH   v, t, m, "(" + mergedParams + ")'" AS ParamList
            WITH   v, t, m, ParamList, replace(v.message, "...", "") AS Message
            WHERE  Message CONTAINS ParamList
            MERGE  (m)-[:HAS_VIOLATION]->(v)
            RETURN count(DISTINCT m) AS LinkedMethods
        ]]></cypher>
        <verify>
            <aggregation/>
        </verify>
    </concept>

    <concept id="pmd:LinkMethodLevelViolationsSingleCandidate">
        <requiresConcept refId="preparation:BiojavaTypes"/>
        <description>Link PMD Violations on method level to method nodes where there is only one candidate based on the number of parameters</description>
        <cypher><![CDATA[
            MATCH  (v:Pmd:Violation),
                   (t:Biojava:Type{fqn: v.package + "." + v.className}),
                   (t)-[:DECLARES]->(m:Method)
            WITH   v, t, m, size(split(t.name, "$")) AS l
            WITH   v, t, m, split(t.name, "$")[l - 1] AS TypeName
            WITH   v, t, m, replace(m.name, "<init>", TypeName) AS MethodName
            WHERE  v.method = MethodName
            OPTIONAL MATCH (m)-[:HAS]->(p:Parameter)-[:OF_TYPE]->(pType:Type)
            WITH   v, t, m, count(p) AS ParameterCount
            WITH   v, t, m, ParameterCount
            WITH   v, t, m, ParameterCount, split(split(v.message, "(")[1], ")'")[0] AS MessageParameters
            WITH   v, t, m, ParameterCount, CASE WHEN size(MessageParameters) = 0 THEN 0 ELSE size(split(MessageParameters, ",")) END AS MessageParameterCount
            WHERE  ParameterCount = MessageParameterCount
            WITH   v, t, collect(m) AS Candidates
            WHERE  size(Candidates) = 1
            UNWIND Candidates AS m
            MERGE  (m)-[:HAS_VIOLATION]->(v)
            RETURN count(DISTINCT m) AS LinkedMethods
        ]]></cypher>
        <verify>
            <aggregation/>
        </verify>
    </concept>

    <concept id="pmd:CopyCyclomaticComplexity">
        <requiresConcept refId="pmd:LinkClassLevelViolations"/>
        <requiresConcept refId="pmd:LinkMethodLevelViolations"/>
        <requiresConcept refId="pmd:LinkMethodLevelViolationsSingleCandidate"/>
        <description>Copy the PMD cyclomatic complexity of the class to the type node</description>
        <cypher><![CDATA[
            MATCH  (j:Java)-[:HAS_VIOLATION]->(v:Pmd:Violation{rule: "CyclomaticComplexity"})
            WITH   split(v.message, " complexity of ") AS parts, j
            WITH   split(parts[1], " ")[0] AS complexity, j
            SET    j.pmdCyclomaticComplexity = toInteger(complexity)
            RETURN count(DISTINCT j) AS CopiedValues
        ]]></cypher>
        <verify>
            <aggregation/>
        </verify>
    </concept>

    <concept id="pmd:CopyNcssLineCount">
        <requiresConcept refId="pmd:LinkClassLevelViolations"/>
        <requiresConcept refId="pmd:LinkMethodLevelViolations"/>
        <requiresConcept refId="pmd:LinkMethodLevelViolationsSingleCandidate"/>
        <description>Copy the PMD ncss line count of the class to the type node</description>
        <cypher><![CDATA[
            MATCH (j:Java)-[:HAS_VIOLATION]->(v:Pmd:Violation{rule: "NcssCount"})
            WITH   split(v.message, " line count of ") AS parts, j
            WITH   split(parts[1], " ")[0] AS ncss, j
            SET    j.ncssLineCount = toInteger(ncss)
            RETURN count(DISTINCT j) AS CopiedValues
        ]]></cypher>
        <verify>
            <aggregation/>
        </verify>
    </concept>

    <concept id="sig:CreateComponentNodes">
        <requiresConcept refId="preparation:BiojavaTypes"/>
        <description>Create a :SIG:Component node per top-level Maven-module</description>
        <cypher><![CDATA[
            MATCH (m:Maven:Project{groupId: "org.biojava", artifactId: "biojava"}),
                  (m)-[:HAS_MODULE]->(child:Maven:Project)
            MERGE (c:Biojava:SIG:Component{name: child.name})
            RETURN c.name AS ComponentName
        ]]></cypher>
    </concept>

    <concept id="sig:MapTypesToComponents">
        <requiresConcept refId="sig:CreateComponentNodes"/>
        <description>Map all types contained directly in a component to the component</description>
        <cypher><![CDATA[
            MATCH  (c:Biojava:SIG:Component),
                   (m:Maven:Project{name: c.name})-[:CREATES]->(:Biojava:Main:Artifact)-[:CONTAINS]->(t:Biojava:Type:Java)
            MERGE  (c)-[:CONTAINS]->(t)
            RETURN c.name AS Component, count(DISTINCT t) AS Types
        ]]></cypher>
    </concept>

    <concept id="sig:AggregateTypeDependenciesToComponentLevel">
        <requiresConcept refId="sig:MapTypesToComponents"/>
        <description>Aggregate DEPENDS_ON relations between modules to components</description>
        <cypher><![CDATA[
            MATCH  (c1:Biojava:SIG:Component)-[:CONTAINS]->(t1:Biojava:Type:Java),
                   (c2:Biojava:SIG:Component)-[:CONTAINS]->(t2:Biojava:Type:Java),
                   (t1)-[d:DEPENDS_ON]->(t2)
            WITH   c1, c2, sum(d.weight) AS weight
            MERGE  (c1)-[d:DEPENDS_ON{weight: weight}]->(c2)
            RETURN c1.name AS Downstream, c2.name AS Upstream
        ]]></cypher>
    </concept>

    <constraint id="pmd:ClassLevelViolationNotLinked">
        <requiresConcept refId="pmd:LinkClassLevelViolations"/>
        <description>Sanity check to see that all class violations were mapped to class nodes</description>
        <cypher><![CDATA[
            MATCH  (v:Pmd:Violation)
            WHERE  NOT exists(v.method) AND NOT (:Type)-[:HAS_VIOLATION]->(v)
            RETURN v.package AS Package, v.className AS Class, v.message AS Violation
        ]]></cypher>
    </constraint>

    <constraint id="pmd:MethodLevelViolationNotLinked">
        <requiresConcept refId="pmd:LinkMethodLevelViolations"/>
        <requiresConcept refId="pmd:LinkMethodLevelViolationsSingleCandidate"/>
        <description>Sanity check to see that all method violations were mapped to method nodes</description>
        <cypher><![CDATA[
            MATCH  (v:Pmd:Violation)
            WHERE  exists(v.method) AND NOT (:Method)-[:HAS_VIOLATION]->(v)
            RETURN v.package AS Package, v.className AS Class, v.method AS Method, v.message AS Violation
        ]]></cypher>
    </constraint>

</jqassistant-rules>